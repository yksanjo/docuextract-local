// Ticket Manager Module
// Files issues automatically to ticketing systems

import { v4 as uuidv4 } from 'uuid';

export class TicketManager {
  constructor() {
    this.providers = this.initializeProviders();
    this.filedTickets = [];
  }

  initializeProviders() {
    return {
      jira: {
        name: 'Jira',
        enabled: false,
        config: {
          url: null,
          project: null,
          apiKey: null
        }
      },
      github: {
        name: 'GitHub Issues',
        enabled: false,
        config: {
          owner: null,
          repo: null,
          token: null
        }
      },
      slack: {
        name: 'Slack',
        enabled: false,
        config: {
          webhookUrl: null,
          channel: null
        }
      },
      webhook: {
        name: 'Custom Webhook',
        enabled: false,
        config: {
          url: null,
          headers: {}
        }
      }
    };
  }

  configure(provider, config) {
    if (this.providers[provider]) {
      this.providers[provider].enabled = true;
      this.providers[provider].config = { ...this.providers[provider].config, ...config };
      console.log(`âœ“ Configured ${this.providers[provider].name}`);
    }
  }

  async fileTickets(remediationResults, scanResults, correlationResults) {
    console.log('\nðŸŽ« Filing tickets...');
    
    const tickets = [];
    const criticalRemediations = remediationResults.remediations.filter(
      r => r.severity === 'critical' || r.severity === 'high'
    );
    
    // File tickets for each critical/high remediation
    for (const remediation of criticalRemediations) {
      const ticket = await this.createTicket(remediation, scanResults, correlationResults);
      tickets.push(ticket);
      this.filedTickets.push(ticket);
    }
    
    // Send Slack notification if configured
    if (this.providers.slack.enabled) {
      await this.sendSlackNotification(tickets);
    }
    
    return {
      ticketId: uuidv4(),
      timestamp: new Date().toISOString(),
      totalTickets: tickets.length,
      tickets,
      summary: {
        critical: tickets.filter(t => t.priority === 'Critical').length,
        high: tickets.filter(t => t.priority === 'High').length,
        medium: tickets.filter(t => t.priority === 'Medium').length
      }
    };
  }

  async createTicket(remediation, scanResults, correlationResults) {
    await this.delay(200);
    
    const ticket = {
      id: uuidv4(),
      key: `SEC-${Math.floor(Math.random() * 10000)}`,
      title: `[${remediation.severity.toUpperCase()}] ${remediation.name}`,
      description: this.generateDescription(remediation, scanResults),
      priority: this.mapSeverityToPriority(remediation.severity),
      severity: remediation.severity,
      status: 'Open',
      assignee: this.autoAssign(remediation),
      components: this.getComponents(remediation),
      labels: this.getLabels(remediation),
      createdAt: new Date().toISOString(),
      remediation: {
        immediate: remediation.immediate,
        shortTerm: remediation.shortTerm,
        longTerm: remediation.longTerm,
        codeSnippet: remediation.codeSnippet
      },
      affectedAssets: remediation.affectedAssets,
      complianceFrameworks: remediation.complianceFrameworks
    };
    
    // Simulate filing to each provider
    if (this.providers.jira.enabled) {
      console.log(`   ðŸ“‹ Filed to Jira: ${ticket.key}`);
    }
    
    if (this.providers.github.enabled) {
      console.log(`   ðŸ“‹ Filed to GitHub Issues: #${ticket.id.slice(0, 4)}`);
    }
    
    return ticket;
  }

  generateDescription(remediation, scanResults) {
    return `## Security Finding: ${remediation.name}

### Severity
${remediation.severity.toUpperCase()} - ${remediation.estimatedEffort} estimated fix time

### Kill Chain Phase
${remediation.killChainPhase || 'N/A'}

### Description
Security issue discovered requiring immediate attention.

### Affected Assets
${remediation.affectedAssets?.map(a => `- ${a.service} (${a.address}:${a.port})`).join('\n') || 'Not specified'}

### Remediation Steps

#### Immediate (within 24 hours)
${remediation.immediate}

#### Short Term (within 1 week)
${remediation.shortTerm}

#### Long Term (within 1 month)
${remediation.longTerm}

${remediation.codeSnippet ? `### Code Fix\n\`\`\`\n${remediation.codeSnippet}\n\`\`\`` : ''}

### Compliance Impact
${remediation.complianceFrameworks?.map(c => `- ${c.framework}: ${c.relevance} relevance`).join('\n') || 'None'}

### Resources
${remediation.resources?.map(r => `- ${r}`).join('\n') || 'None'}

---
*Generated by Autonomous Security Copilot*
*Timestamp: ${new Date().toISOString()}*`;
  }

  mapSeverityToPriority(severity) {
    const mapping = {
      critical: 'Critical',
      high: 'High',
      medium: 'Medium',
      low: 'Low'
    };
    return mapping[severity] || 'Medium';
  }

  autoAssign(remediation) {
    // Auto-assignment logic based on severity and type
    if (remediation.severity === 'critical') {
      return 'Security Team';
    }
    
    if (remediation.name?.toLowerCase().includes('database')) {
      return 'DBA Team';
    }
    
    if (remediation.name?.toLowerCase().includes('authentication') || 
        remediation.name?.toLowerCase().includes('ssh')) {
      return 'Infrastructure Team';
    }
    
    return 'Development Team';
  }

  getComponents(remediation) {
    const components = [];
    
    if (remediation.affectedAssets) {
      for (const asset of remediation.affectedAssets) {
        if (asset.service) {
          components.push(asset.service);
        }
      }
    }
    
    return [...new Set(components)]; // Unique
  }

  getLabels(remediation) {
    const labels = ['security', remediation.severity];
    
    if (remediation.killChainPhase) {
      labels.push(remediation.killChainPhase.toLowerCase().replace(' ', '-'));
    }
    
    if (remediation.complianceFrameworks) {
      for (const framework of remediation.complianceFrameworks) {
        labels.push(framework.framework.toLowerCase());
      }
    }
    
    return labels;
  }

  async sendSlackNotification(tickets) {
    console.log(`   ðŸ“¢ Sending Slack notification for ${tickets.length} tickets...`);
    await this.delay(100);
    
    // In a real implementation, this would send an actual webhook
    console.log(`   âœ“ Slack notification sent to #security-alerts`);
  }

  getFiledTickets() {
    return this.filedTickets;
  }

  getTicketStats() {
    return {
      total: this.filedTickets.length,
      open: this.filedTickets.filter(t => t.status === 'Open').length,
      critical: this.filedTickets.filter(t => t.severity === 'critical').length,
      high: this.filedTickets.filter(t => t.severity === 'high').length
    };
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export default TicketManager;
